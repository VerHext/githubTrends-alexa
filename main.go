package main

import (
	"net/http"
	"log"
	"io/ioutil"
	"fmt"
	"strings"
	"encoding/json"
	"os"
)

type AutoGenerated []struct {
	Username string `json:"username"`
	URL      string `json:"url"`
	Avatar   string `json:"avatar"`
	Repo     struct {
		Name        string `json:"name"`
		Description string `json:"description"`
		URL         string `json:"url"`
	} `json:"repo"`
	Name string `json:"name,omitempty"`
}

func github(w http.ResponseWriter, r *http.Request) {

		url := "http://github-trending-api.now.sh/developers?since=today&size=1"
		payload := strings.NewReader("{\r\n        \"backlog_order\": 2,\r\n        \"description\": \"Debugtest\",\r\n        \"project\": 1,\r\n        \"sprint_order\": 1,\r\n        \"status\": 1,\r\n        \"subject\": \"Customer personal data\",\r\n        \"tags\": [\r\n            \"support\",\r\n            \"email\"\r\n        ]\r\n    }")

		req, _ := http.NewRequest("GET", url,payload )

		req.Header.Add("cache-control", "no-cache")
		res, _ := http.DefaultClient.Do(req)

		defer res.Body.Close()
		body, _ := ioutil.ReadAll(res.Body)

		fmt.Println(res)
		fmt.Println(string(body))

		dj := AutoGenerated{};
			json.Unmarshal([]byte(string(body)), &dj)

			fmt.Println("Pla " , dj[0].Username)
	w.Write([]byte("Auf Platz 1: " +dj[0].Repo.Name +" von " + dj[0].Username +  ". Platz 2: " +dj[1].Repo.Name +" von " + dj[1].Username + ". Und auf Platz 3. " +dj[2].Repo.Name +" von " + dj[2].Username+
		". Platz 4 " +dj[3].Repo.Name +" von " + dj[4].Username + ". Und den Platz 5 belegt: "+dj[4].Repo.Name +" von " + dj[4].Username))

}


func gitlab(w http.ResponseWriter, r *http.Request) {

	w.Write([]byte("Auf Platz 1: gitlab-ce von gitlab-org. Platz 2: fdroidclient von fdroid. Und auf Platz 3. gitlab-runner von gitlab-org. Platz 4 inkscape von inkscape. Und den Platz 5 belegt: awesome-django von rosarior."))

}

func main() {
	http.HandleFunc("/github", github) // set router
	http.HandleFunc("/gitlab", gitlab)
	err := http.ListenAndServe(":" +os.Getenv("PORT"), nil) // set listen port
	if err != nil {
		log.Fatal("ListenAndServe: ", err)
	}
}
